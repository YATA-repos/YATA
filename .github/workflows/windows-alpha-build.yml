name: Windows Build (Alpha Tags)

on:
  push:
    tags:
      - 'v*.*.*-alpha*'

permissions:
  contents: read

jobs:
  build-windows:
    name: Build Windows runner
    runs-on: windows-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: stable

      - name: Generate environment file
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_OAUTH_CALLBACK_URL_DEV: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_DEV }}
          SUPABASE_OAUTH_CALLBACK_URL_PROD: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_PROD }}
          SUPABASE_OAUTH_CALLBACK_URL_MOBILE: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_MOBILE }}
          SUPABASE_OAUTH_CALLBACK_URL_DESKTOP: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_DESKTOP }}
          DEBUG_MODE: ${{ secrets.DEBUG_MODE }}
          LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
          LOG_DIR: ${{ secrets.LOG_DIR }}
          LOG_FLUSH_INTERVAL_MS: ${{ secrets.LOG_FLUSH_INTERVAL_MS }}
          LOG_MAX_QUEUE: ${{ secrets.LOG_MAX_QUEUE }}
          LOG_MAX_FILE_SIZE_MB: ${{ secrets.LOG_MAX_FILE_SIZE_MB }}
          LOG_MAX_DISK_MB: ${{ secrets.LOG_MAX_DISK_MB }}
          LOG_RETENTION_DAYS: ${{ secrets.LOG_RETENTION_DAYS }}
          LOG_BACKPRESSURE: ${{ secrets.LOG_BACKPRESSURE }}
          ORDER_MANAGEMENT_PERF_TRACING: ${{ secrets.ORDER_MANAGEMENT_PERF_TRACING }}
        run: |
          set -euo pipefail

          required=(SUPABASE_URL SUPABASE_ANON_KEY)
          for key in "${required[@]}"; do
            value="${!key:-}"
            if [ -z "$value" ]; then
              echo "::error::Missing required secret: $key"
              exit 1
            fi
          done

          {
            printf "SUPABASE_URL=%s\n" "$SUPABASE_URL"
            printf "SUPABASE_ANON_KEY=%s\n" "$SUPABASE_ANON_KEY"
          } > .env

          optional=(
            SUPABASE_OAUTH_CALLBACK_URL_DEV
            SUPABASE_OAUTH_CALLBACK_URL_PROD
            SUPABASE_OAUTH_CALLBACK_URL_MOBILE
            SUPABASE_OAUTH_CALLBACK_URL_DESKTOP
            DEBUG_MODE
            LOG_LEVEL
            LOG_DIR
            LOG_FLUSH_INTERVAL_MS
            LOG_MAX_QUEUE
            LOG_MAX_FILE_SIZE_MB
            LOG_MAX_DISK_MB
            LOG_RETENTION_DAYS
            LOG_BACKPRESSURE
            ORDER_MANAGEMENT_PERF_TRACING
          )

          for key in "${optional[@]}"; do
            value="${!key:-}"
            if [ -n "$value" ]; then
              printf "%s=%s\n" "$key" "$value" >> .env
            fi
          done

      - name: Enable Windows desktop
        run: flutter config --enable-windows-desktop

      - name: Fetch Flutter dependencies
        run: flutter pub get

      - name: Generate code with build_runner
        run: flutter pub run build_runner build --delete-conflicting-outputs

      - name: Build Windows release runner
        run: flutter build windows --release --dart-define-from-file=.env

      - name: Remove environment file
        if: always()
        run: rm -f .env

      - name: Prepare installer workdir
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path installer\workdir | Out-Null

          $source = Join-Path (Get-Location) 'build/windows/x64/runner/Release'
          if (-not (Test-Path $source)) {
            throw "Release directory not found at $source"
          }

          Copy-Item -Path "$source\*" -Destination installer\workdir -Recurse -Force

      - name: Flatten installer directory
        shell: pwsh
        run: |
          $root = [System.IO.Path]::GetFullPath((Join-Path (Get-Location) 'installer\workdir'))
          Write-Host "Root directory: $root"
          
          $exeFiles = Get-ChildItem -Path $root -Recurse -Filter 'yata.exe' -File
          Write-Host "Found $($exeFiles.Count) yata.exe file(s)"
          
          if ($exeFiles.Count -eq 0) {
            Write-Host "=== Available files in workdir ==="
            Get-ChildItem -Path $root -Recurse -File | ForEach-Object {
              Write-Host $_.FullName
            }
            throw "yata.exe が ${root} 以下で見つかりませんでした。"
          }
          
          $releasePath = [System.IO.Path]::GetFullPath($exeFiles[0].DirectoryName)
          Write-Host "yata.exe found at: $releasePath"

          $normalizedReleasePath = $releasePath.TrimEnd('\\')
          $normalizedRoot = $root.TrimEnd('\\')
          
          Write-Host "Comparing paths:"
          Write-Host "  Release: '$normalizedReleasePath'"
          Write-Host "  Root:    '$normalizedRoot'"
          
          if ($normalizedReleasePath -ieq $normalizedRoot) {
            Write-Host 'Runner contents are already flattened.'
          }
          else {
            Write-Host "Moving files from subdirectory to root"
            Get-ChildItem -Path $releasePath -Force | ForEach-Object {
              $targetPath = Join-Path $root $_.Name
              Write-Host "  Moving $($_.Name) to $targetPath"
              Move-Item -Path $_.FullName -Destination $targetPath -Force
            }

            Write-Host "Cleaning up empty directories"
            Remove-Item -Path $releasePath -Recurse -Force -ErrorAction SilentlyContinue

            $parent = Split-Path $releasePath
            while ($parent -and (Test-Path $parent) -and ($parent -like "$root*") -and ($parent -ine $root)) {
              if (-not (Get-ChildItem -Path $parent -Force -ErrorAction SilentlyContinue)) {
                Write-Host "  Removing empty directory: $parent"
                Remove-Item -Path $parent -Force
                $parent = Split-Path $parent
              }
              else {
                break
              }
            }
          }
          
          Write-Host "=== Final workdir structure ==="
          Get-ChildItem -Path $root | ForEach-Object {
            Write-Host $_.Name
          }

      - name: Install Inno Setup
        shell: pwsh
        run: |
          choco install innosetup --version=6.2.2 -y
          if ($LASTEXITCODE -ne 0) {
            throw "Failed to install Inno Setup via Chocolatey."
          }
          
          $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          
          $iscc = Get-Command iscc -ErrorAction SilentlyContinue
          if (-not $iscc) {
            throw "ISCC (Inno Setup) not found in PATH after installation."
          }

      - name: Write Inno Setup script
        shell: pwsh
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          SUPABASE_OAUTH_CALLBACK_URL_DEV: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_DEV }}
          SUPABASE_OAUTH_CALLBACK_URL_PROD: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_PROD }}
          SUPABASE_OAUTH_CALLBACK_URL_MOBILE: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_MOBILE }}
          SUPABASE_OAUTH_CALLBACK_URL_DESKTOP: ${{ secrets.SUPABASE_OAUTH_CALLBACK_URL_DESKTOP }}
          DEBUG_MODE: ${{ secrets.DEBUG_MODE }}
          LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
          LOG_DIR: ${{ secrets.LOG_DIR }}
          LOG_FLUSH_INTERVAL_MS: ${{ secrets.LOG_FLUSH_INTERVAL_MS }}
          LOG_MAX_QUEUE: ${{ secrets.LOG_MAX_QUEUE }}
          LOG_MAX_FILE_SIZE_MB: ${{ secrets.LOG_MAX_FILE_SIZE_MB }}
          LOG_MAX_DISK_MB: ${{ secrets.LOG_MAX_DISK_MB }}
          LOG_RETENTION_DAYS: ${{ secrets.LOG_RETENTION_DAYS }}
          LOG_BACKPRESSURE: ${{ secrets.LOG_BACKPRESSURE }}
          ORDER_MANAGEMENT_PERF_TRACING: ${{ secrets.ORDER_MANAGEMENT_PERF_TRACING }}
        run: |
          New-Item -ItemType Directory -Force -Path installer\out | Out-Null

          function New-EnvironmentEntry {
            param(
              [Parameter(Mandatory = $true)][string] $Name,
              [Parameter(Mandatory = $true)][string] $Value
            )

            $escaped = $Value -replace '"', '""'
            return ('Name: "{0}"; Value: "{1}"; Flags: machine' -f $Name, $escaped)
          }

          $requiredEnvKeys = @('SUPABASE_URL', 'SUPABASE_ANON_KEY')
          $optionalEnvKeys = @(
            'SUPABASE_OAUTH_CALLBACK_URL_DEV',
            'SUPABASE_OAUTH_CALLBACK_URL_PROD',
            'SUPABASE_OAUTH_CALLBACK_URL_MOBILE',
            'SUPABASE_OAUTH_CALLBACK_URL_DESKTOP',
            'DEBUG_MODE',
            'LOG_LEVEL',
            'LOG_DIR',
            'LOG_FLUSH_INTERVAL_MS',
            'LOG_MAX_QUEUE',
            'LOG_MAX_FILE_SIZE_MB',
            'LOG_MAX_DISK_MB',
            'LOG_RETENTION_DAYS',
            'LOG_BACKPRESSURE',
            'ORDER_MANAGEMENT_PERF_TRACING'
          )

          $environmentLines = New-Object System.Collections.Generic.List[string]

          foreach ($key in $requiredEnvKeys) {
            $value = [Environment]::GetEnvironmentVariable($key)
            if ([string]::IsNullOrWhiteSpace($value)) {
              throw "Required environment secret '$key' is missing or empty."
            }
            $environmentLines.Add((New-EnvironmentEntry -Name $key -Value $value))
          }

          foreach ($key in $optionalEnvKeys) {
            $value = [Environment]::GetEnvironmentVariable($key)
            if (-not [string]::IsNullOrWhiteSpace($value)) {
              $environmentLines.Add((New-EnvironmentEntry -Name $key -Value $value))
            }
          }

          $lines = @(
            '#ifndef AppVersion'
            '#define AppVersion "0.0.0"'
            '#endif'
            ''
            '[Setup]'
            'AppId={{1B9A9E73-4C46-4E3A-9D9E-3A7F8EACB001}}'
            'AppName=YATA'
            'AppVersion={#AppVersion}'
            'DefaultDirName={pf}\YATA'
            'DefaultGroupName=YATA'
            'DisableProgramGroupPage=yes'
            'OutputDir={#SourcePath}out'
            'OutputBaseFilename=YATA-{#AppVersion}-setup'
            'Compression=lzma'
            'SolidCompression=yes'
            'ArchitecturesInstallIn64BitMode=x64'
            'WizardStyle=modern'
            'ChangesEnvironment=yes'
            ''
            '[Files]'
            'Source: "{#SourcePath}workdir\*"; DestDir: "{app}"; Flags: recursesubdirs ignoreversion'
            ''
            '[Tasks]'
            'Name: "desktopicon"; Description: "デスクトップにショートカットを作成"; GroupDescription: "追加のアイコン:"; Flags: checkedonce'
            ''
            '[Icons]'
            'Name: "{autoprograms}\YATA"; Filename: "{app}\yata.exe"; IconFilename: "{app}\yata.exe"'
            'Name: "{autodesktop}\YATA"; Filename: "{app}\yata.exe"; IconFilename: "{app}\yata.exe"; Tasks: desktopicon'
          )

          if ($environmentLines.Count -gt 0) {
            $lines += ''
            $lines += '[Environment]'
            $lines += $environmentLines.ToArray()
          }

          $lines += @(
            ''
            '[Run]'
            'Filename: "{app}\yata.exe"; Description: "YATA を起動"; Flags: nowait postinstall skipifsilent'
          )

          $lines | Set-Content -Path installer\YATA.iss -Encoding UTF8BOM

      - name: Compile installer
        shell: pwsh
        run: |
          $version = $env:GITHUB_REF_NAME -replace '^v', ''
          Write-Host "Using version: $version"
          
          $iscc = (Get-Command iscc).Source
          & $iscc /Qp /DAppVersion="$version" installer\YATA.iss
          if ($LASTEXITCODE -ne 0) { throw "Inno Setup compile failed." }
          Get-ChildItem installer\out\*.exe | ForEach-Object FullName

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: yata-windows-alpha-installer
          path: installer\out\*.exe
          if-no-files-found: error

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: yata-windows-alpha-runner
          path: build/windows/x64/runner/Release/**
