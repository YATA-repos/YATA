# Fatal ログ運用整備計画 (2025-10-05)

## 背景
- 現状 `log.f`（fatal）レベルの利用実績がなく、重大障害発生時の通知・復旧フローが定義されていない。
- ロガーにはクラッシュ捕捉や外部連携の仕組みが存在するが、致命的イベントをトリガーに活用できていない。

## 目的
- Fatal ログの定義と運用ルールを策定し、致命的な障害時に確実に通知・エスカレーションされる体制を整える。
- `log.f` 発生時にクラッシュレポーティングや緊急通知を発火できるようなハンドリングを実装する。

## ゴール
- Fatal レベルの利用判断基準とメッセージテンプレートがドキュメント化されている。
- `Logger` に Fatal レベル発生時のハンドラが登録され、通知/クラッシュ連携が機能している。
- 少なくとも 1 つの致命パス（例: 永続化できないリカバリ不能エラー）で `log.f` が実装されている。

## スコープ外
- 外部監視サービスとの本番連携（Webhook など）は PoC とし、正式導入は別イテレーションで検討。

## 対応方針
1. **Fatal レベルの定義策定**
   - どのような事象を Fatal とするか、例: 起動不能、データ破損検知、クリティカル依存の初期化失敗。
   - エスカレーション先や一次対応者を運用チームと合意。
2. **ハンドラ実装**
   - `infra/logging/logger.dart` に Fatal レベル発火時のコールバックを追加し、`installCrashCapture` との役割を整理。
   - `log_runtime_config` で Fatal 時の動作（強制フラッシュ等）を設定可能にする案を検討。
3. **PoC 実装**
   - 例: Supabase 初期化が連続失敗した際に Fatal ログを吐いてアプリをセーフモードに遷移。
   - Fatal ログ発火時に `FileSink` などの書き込み完了を待ってからアプリ終了するフローを確認。

## 作業手順
1. Fatal 運用ポリシーをドキュメント化（`docs/standards/logging_levels.md` へ追記）。
2. Logger に Fatal ハンドラを追加し、Crash 捕捉処理と連携。
3. ハンドラ内で通知（例: Sentry, Slack Webhook）への連携をインターフェース化して注入可能にする。
4. 代表ケースで Fatal ログを実装し、挙動を検証。
5. テストとレビューを経てポリシーを運用へ展開。

## 検証計画
- 単体テストで Fatal ハンドラが呼ばれることを検証。
- `integration_test` もしくはデバッグビルド上で Fatal シナリオをトリガーし、通知とアプリ挙動を確認。
- 通知連携が未実装の場合はモックを用いてログ/アサートで確認。

## リスク / 留意事項
- Fatal 発生時に無限ループやクラッシュが連鎖しないよう、ハンドラ内の処理を冪等に保つ。
- 強制終了前にログ書き込みを同期させる必要があり、UI レスポンスへの影響を最小限に抑える設計が必要。
- 本番通知先が未確定の場合、暫定実装で保留にならないようステークホルダー調整が重要。

## 成功指標
- Fatal シナリオのデモで通知が期待通り発火する。
- 運用マニュアルに Fatal レベルの対応手順が追記され、オンコール体制で共有済み。
- 実装後 1 ヶ月以内に少なくとも 1 度レビューで Fatal ログガイドラインが参照された実績がある。
