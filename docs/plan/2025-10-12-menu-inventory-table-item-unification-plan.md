# メニュー/在庫テーブルアイテム共通化計画 (2025-10-12)

## 1. 背景と課題認識
- メニュー管理 (`lib/features/menu/presentation/widgets/menu_item_table.dart`) と在庫管理 (`lib/features/inventory/presentation/pages/inventory_management_page.dart`) は `YataDataTable` を共有しているが、行データの生成・表示ロジックは個別に実装されており重複と拡張性の低下を招いている。
- それぞれのテーブルに独自のビュー用データクラス (`MenuItemViewData`, `InventoryRowViewData`) と UI ギミック（販売可否トグル、在庫差分ステッパーなど）が存在し、列構成・操作導線の乖離により UX とコード保守性が悪化している。
- 今後、販売分析やレシピ管理など他画面でもテーブル表現が増加する見込みであり、行アイテムを共通化した拡張しやすい設計が求められる。

### 1.1 現状差分スナップショット
- **列定義**: メニュー側は固定7列（カテゴリ/価格/販売状態など）、在庫側はソートハンドラ付き6列＋操作列。列メタ情報がハードコードされている。
- **行レイアウト**: メニューは `DataCell` 内でバッジやトグルを直書き、在庫は Busy オーバーレイや数量ステッパーを埋め込むなどカスタムが散在。
- **状態管理**: Riverpod の状態は `MenuItemViewData` / `InventoryRowViewData` に分かれ、UI 側での Busy/Error 表示の契約が統一されていない。
- **テスト**: テーブル項目の snapshot/behavior テストが限定的で、共通コンポーネントとしての回帰検証が難しい。

## 2. ゴールと非ゴール
- **ゴール**
  - テーブル行アイテムの共通データ構造と描画コンポーネントを整備し、メニュー・在庫両画面で再利用する。
  - 列定義やソート情報をメタデータ化し、追加画面でも流用できる仕組みを整える。
  - 既存 UX（販売トグル、在庫調整、バッジ表示）は維持しつつ、共通化後の保守性とテスト容易性を向上させる。
- **非ゴール**
  - テーブル以外の画面レイアウト刷新。
  - Supabase API やドメインモデルの抜本的な再設計。
  - 表示列の仕様再定義（必要に応じて別途ディスカッションとする）。

## 3. 共通化に必要な要件
1. 行アイテムは「ラベル」「サブテキスト」「バッジ」「アクション」「補助操作（トグル/ステッパー等）」を表現できる柔軟なコンテナであること。
2. 列のラベル・ソートキー・幅・アライメントなどのメタ情報を宣言的に定義し、モジュールごとの差し替えを許容すること。
3. 行単位の Busy / Error / Tooltip / セマンティクス情報を共通インターフェースで扱えること。
4. モバイル/デスクトップ両方でのレスポンシブ表示に影響しないこと（既存 `YataDataTable` の挙動を維持）。
5. Riverpod 状態 → テーブル行データへのマッピングを段階的に移行できること（段階的リリースを想定）。
6. 既存テスト（`test/shared/components/data_display/data_table_test.dart` など）の落ち込みを防ぎ、必要に応じて追加テストを整備できること。

## 4. 方針案
### 4.1 データモデルの共通化
- `lib/shared/components/data_display/` 配下に新たな抽象 `YataTableColumnSpec` / `YataTableRowSpec`（仮称）を定義し、列ラベルやセル種別（テキスト/バッジ/操作）を宣言的に表現する。
- メニュー・在庫それぞれのコントローラ層では既存 ViewData を維持しつつ、UI に渡す段で `YataTableRowSpec` へ変換するアダプタを実装。段階移行期間中は ViewData と RowSpec の両方を併存させる。
- 行内で必要なインタラクション（トグル、ステッパー、ボタン）は `YataTableCell` の一種としてコールバック/Busy 状態を引き渡せるよう設計する。

### 4.2 UI コンポーネントの整理
- `YataDataTable` に `List<YataTableColumnSpec>` と `List<YataTableRowSpec>` を受け取る新コンストラクタを追加し、既存 `DataColumn` / `DataRow` の生成を内部に隠蔽。
- メニュー・在庫のテーブルウィジェットは新方式に切り替え、既存 UI の差分は RowSpec 内のセル構成で表現する。
- Busy オーバーレイやエラーメッセージは行レベルのメタデータで吸収し、UI 側で統一レイアウトを提供する。

### 4.3 ソート・フィルタ・アクセシビリティ
- 列メタにソートキーの enum を紐付け、`onSort` 呼び出しを共通ハンドラに委譲する仕組みを整える。
- 行アクション（例: メニュー詳細ダイアログ、在庫編集）は RowSpec の `primaryAction` / `secondaryActions` で表現し、`onRowTap` との整合性を取る。
- アクセシビリティ（Semantics）情報は RowSpec に `ariaLabel` 的フィールドを持たせ、長文セルにも対応する。

## 5. 実行ロードマップ
| フェーズ | 期間目安 | 目的 | 主なタスク |
| --- | --- | --- | --- |
| Phase 0 | 0.5週間 | 基礎調査・仕様固め | 既存テーブル挙動の洗い出し、要件レビュー、`YataTable*` 抽象の API 設計ドラフト作成、関係者合意形成 |
| Phase 1 | 1週間 | 基盤実装 | 共通カラム/行スペック実装、`YataDataTable` 拡張、Widget テスト作成（生成結果/アクセシビリティ検証）、既存コードへの影響把握 |
| Phase 2 | 1週間 | メニュー画面移行 | `MenuItemTable` を RowSpec ベースに書き換え、Controller のアダプタ導入、販売トグル/エラー表示の挙動確認、回帰テスト |
| Phase 3 | 1.5週間 | 在庫画面移行 | `_InventoryTable` の RowSpec 化、調整ステッパーや Busy オーバーレイの共通化、ソート・フィルタ連携の再確認、E2E/ゴールデンテスト更新 |
| Phase 4 | 0.5週間 | 仕上げ | 重複コード削除、ドキュメント整備、他画面展開のテンプレート作成、技術的負債/残タスク整理 |

## 6. リスクと緩和策
- **複雑なセルUIの抽象化難易度**: 在庫テーブルの調整カラムのような複雑セルが共通抽象に収まりきらない可能性 → `customBuilder` スロットを用意し、柔軟性を確保。
- **段階移行中の破壊的変更**: 片方のみ新仕様に切り替えた状態でリリースすると UX が異なる → フラグで切り替え、同一スプリント内で両画面を移行する。
- **テスト観点の抜け漏れ**: 共通化によって既存 Widget テストが陳腐化 → 行スペックを JSON 風にアサートする新しいテストユーティリティを整備し、フィクスチャ更新コストを下げる。
- **パフォーマンス懸念**: 行スペック生成により rebuild コストが増加する可能性 → `const` 化や `ValueKey` 利用で再構築を最小化、パフォーマンス計測を Phase 1 で実施。

## 7. 成果物と検証指標
- `lib/shared/components/data_display/` に共通テーブル抽象とドキュメントコメントを追加。
- メニュー・在庫両画面が新 RowSpec を使用し、コード重複（列定義、セル組み立て）が削減されていること。
- Widget テスト（メニュー表示、在庫表示）でセル構成とアクションが期待通りであることを確認。
- QA チェックリスト: ソート、トグル、ステッパー、Busy/Error 表示、空データ時の表示が従来通り機能する。

## 8. オープン課題・要ディスカッション
- 新抽象の命名・配置（`shared/components` か `shared/table` か）と今後の展開範囲。
- テーブル列のレスポンシブ挙動（列折り返しやコンパクト表示）をどこまで共通化するか。
- 行スペックをバックエンド由来の JSON に展開する将来構想の有無。
- 在庫テーブル特有のセクションカードレイアウトをどう扱うか（共通カード化の必要性）。

## 9. 次アクション
1. 本計画案をメニュー/在庫担当と共有し、要件妥当性レビューを実施（Phase 0 の一環）。
2. `YataTable*` 抽象の API ドラフトを `docs/draft/` に作成し、実装前レビューを受ける。
3. Phase 0 完了後、Phase 1 の実装スプリントをセットアップし、テーブル共通化の PoC を並行で進める。
