# カウントベース注文番号採番計画 (2025-09-29)

## 背景
- 現在の `OrderRepository.generateNextOrderNumber()` は当日注文を全件取得してから件数+1で連番を決定している。
- データ件数が増えるほどフェッチ量が増大し、チェックアウト処理のレイテンシ悪化が懸念される。
- 同時アクセス時はレスポンス遅延に加え、件数計算までの間に他要求が完了すると重複番号が発生するリスクも残る。

## 目的
- 当日注文件数を軽量に把握し、注文番号採番処理のパフォーマンスを改善する。
- 将来的な同時アクセス対策（ユニーク制約追加や楽観ロック等）へ発展できる足場を整備する。

## スコープ
- `OrderRepository.generateNextOrderNumber()` の計算方式を「対象件数のカウント取得」に置き換える。
- 関連するユニットテスト／サービス層テストの追加・更新。
- 表示フォーマットや採番形式（`yyyyMMdd-連番`）は変更しない。
- DBスキーマ変更やユニーク制約追加は本計画の範囲外（必要なら別計画で扱う）。

## 変更概要
### リポジトリ層
- `_delegate.find(...)` を `_delegate.count(...)` に置き換え、当日注文数をカウントのみで取得する。
- `QueryConditionBuilder` のフィルタに以下を検討:
  - `ordered_at` の日付範囲 (現状踏襲)。
  - `order_number` が `NULL` でない条件を追加し、未確定カートをカウント対象から除外。
- 取得した件数 + 1 をゼロ埋め 3 桁で整形する処理は既存を再利用。

### テスト
- `OrderRepository.generateNextOrderNumber()` のユニットテストを作成または更新し、以下を検証:
  - 当日の既存注文数に応じた連番生成。
  - `order_number` が `NULL` のレコードを除外すること。
  - カウント取得時の例外ハンドリング。
- `OrderManagementService.checkoutCart()` の主要フローが新ロジックでも成立することを確認するサービス層テスト（既存テスト再利用 or モック更新）。

### ロギング・監視 (任意)
- 採番時に取得したカウント値をデバッグログに残す案を検討し、障害調査を容易にする。

## タスク
1. `OrderRepository.generateNextOrderNumber()` を `count` ベースにリファクタリング。
2. フィルタ条件へ `order_number IS NOT NULL` を追加（要件確認後に実施）。
3. 既存テストの更新と新規テストの追加。
4. 必要に応じてモック (`MockCrudRepository` 等) の `count` 呼び出し対応を確認・調整。
5. ログ/ドキュメント更新（本計画を docs/draft から参照する場合はリンク追加）。

## リスクと軽減策
- **カウントの整合性**: Supabase 側が `count` パラメータを適切に処理しない場合、結果が `null` になる可能性 → 例外処理とフェールセーフ（例: 0 とみなす）を実装。
- **同時採番の重複**: カウント方式でも並列実行で競合する可能性は残る → 今回はパフォーマンス改善に集中し、重複検知は別タスクで検討。
- **テストモックの非対応**: 既存モックが `count` 未実装の場合はテストが失敗 → 事前にモック実装を確認し、必要なら `count` を実装。

## アウトカム / 完了条件
- リポジトリの採番実装が `count` ベースに移行し、当日の注文件数増加でもレスポンス遅延が目に見えて減少する（推定ベンチマーク含む）。
- 新旧実装差分を説明できるテストが通過する。
- 開発者向けドキュメント（本計画含む）が更新され、後続タスクの指針が明確になっている。

## 未解決事項 / フォローアップ
- Supabase（PostgreSQL）側でのシーケンス利用またはユニーク制約追加の検討。
- タイムゾーン問題（`DateTime.now()` 依存）への恒久対応案。
- 採番APIの同期実行による UX 影響評価（必要なら非同期化／楽観 UI を検討）。
