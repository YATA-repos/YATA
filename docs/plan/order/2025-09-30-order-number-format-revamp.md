# 注文番号フォーマット刷新計画 (2025-09-30)

## 背景
- 現在の注文番号は `yyyyMMdd-連番` 形式で、`OrderRepository.generateNextOrderNumber()` が当日件数 + 1 のシーケンシャル番号を採番している。
- 同時チェックアウト時の重複リスクや、件数カウントに伴う待ち時間が懸念されている。
- 今回、より一意性が高く追跡しやすいフォーマットへの刷新要望が上がった。

## 目的
- 注文番号を `<YYYYMMDDThhmmss+0900>-<ランダムスラッグ>` 形式へ変更し、
  - 秒精度タイムスタンプで生成時刻を表現。
  - CSPRNG を用いた Base62 (11 文字) 乱数でユニーク性を担保。
- 採番ロジックの衝突リスクを低減しつつ、既存のチェックアウトフローと互換性を維持する。
- Supabase 側スキーマや制約を同期させ、将来的な検索・監査要件に備える。

## スコープ
### Flutter アプリ側
- `OrderRepository.generateNextOrderNumber()` のロジックを新フォーマットへ差し替え。
- CSPRNG + Base62 乱数生成のユーティリティ追加 (再利用可能なヘルパーを推奨)。
- 採番タイミング (`OrderManagementService.checkoutCart`) は現状通り。副作用・呼び出し側の変更点を精査。
- 既存単体テスト・サービス層テストの更新、および新フォーマット検証用テスト追加。
- UI / ロギングで注文番号を文字列として扱っている箇所を確認し、フォーマット前提のロジック（例: 連番部分のパース）が存在しないかを洗い出す。

### Supabase 側
- `orders.order_number` カラムのデータ型・長さ制約の再確認。必要に応じて `text` もしくは十分な `varchar` へマイグレーション。
- `order_number` に対する一意制約（`UNIQUE`）を追加。NULL 許容のまま、`WHERE order_number IS NOT NULL` 条件付きインデックスを利用。
- 既存データの互換性確認（旧フォーマット値はそのまま保持して問題なし）。
- 管理用ビュー／ファンクションが旧フォーマットを前提にしていないか確認し、必要なら更新。
- 監査ログ／外部連携があれば新フォーマットを通知。

### 非スコープ
- 注文番号の再採番、既存履歴の書き換え。
- Supabase 外部システム連携の仕様変更（必要であれば別計画で扱う）。

## 新フォーマット仕様
- 文字列構造: `<DATETIME>-<SLUG>`
  - `DATETIME`: `YYYYMMDDThhmmss+0900`
    - 例: `20250930T154512+0900`
    - JST 固定。端末タイムゾーンが異なる場合も JST に変換して出力する。
  - `SLUG`: Base62 (0-9, A-Z, a-z) 11 文字。
    - 88 bit 相当のエントロピー。`Random.secure()` から得たバイト列を Base62 エンコード。
- 総文字数: 20 + 1 + 11 = 32 文字。
- UI や帳票での表示は従来同様に文字列をそのまま扱う。連番ではないため昇順ソートは `ordered_at` を利用する方針を徹底。

## 実装タスク
### 1. 下準備
- 関連ドキュメントの確認 (`docs/draft/order_number_generation.md` 等)。
- 既存フォーマットに依存するロジック（検索、ソート、整形表示）を列挙。
- Supabase スキーマの現状 (`\\d orders` 等) を確認し、カラム定義や既存インデックス情報を把握。

### 2. Flutter アプリ改修
1. 共通ユーティリティ（例: `lib/shared/utils/random_slug_generator.dart`）を新設し、以下を実装。
   - `generateJstTimestampString()`：`DateTime.now()` を JST (`+09:00`) に変換してフォーマット。
   - `generateBase62Slug(int length)`：`Random.secure()` で必要ビット数を確保し Base62 へ変換。
   - 端数ビット処理・再生成ループで 11 文字を保証。
2. `OrderRepository.generateNextOrderNumber()` を新ヘルパー利用に書き換え。
   - 既存の日付算出・カウントロジックを削除。
   - エラーハンドリング (例外時ログ) は維持。
3. `OrderManagementService.checkoutCart` 他、`generateNextOrderNumber()` を利用する箇所の動作確認。
4. テストの更新
   - ユニットテスト: フォーマット（Regex）と CSPRNG 呼び出し回数、JST タイムスタンプの生成を検証。
   - サービス層テスト: 採番結果が非 null であり、旧フォーマット依存ロジックがないことを確認。
   - モック／スタブの追加が必要な場合、Base62 ユーティリティを差し替え可能な構造にしてテストしやすくする（DI or テスタブルファクトリ）。
5. 既存ドキュメントの更新 (`docs/draft/order_number_generation.md` 等)。

### 3. Supabase マイグレーション
1. カラム定義の見直し
   - 現状が `varchar(12)` など長さ制限付きの場合、`text` または `varchar(64)` に拡張。
   - マイグレーション例: `ALTER TABLE orders ALTER COLUMN order_number TYPE varchar(64);`
2. ユニークインデックス追加
   - `CREATE UNIQUE INDEX orders_order_number_unique_not_null ON orders (order_number) WHERE order_number IS NOT NULL;`
3. (任意) パターン検証用 CHECK 制約
   - 例: `CHECK (order_number ~ '^[0-9]{8}T[0-9]{6}\+0900-[0-9A-Za-z]{11}$' OR order_number IS NULL)`
   - 旧フォーマットレコードが存在するため、即時導入できない場合は段階的に検討（旧データ許容するなら今回は見送り）。
4. 関連ビュー／ファンクション更新
   - `order_number` の長さや連番部分に依存したロジックがないか確認し、あれば修正。
5. マイグレーション手順書作成
   - ステージングでマイグレーション適用 → リグレッションテスト → 本番適用。

### 4. ロールアウト手順 (案)
1. Supabase スキーマ変更をステージングへ適用。
2. Flutter アプリ改修をステージングへデプロイし、採番・検索・表示を確認。
3. 旧フォーマットと新フォーマットが混在する状態での整合性検証（履歴検索、分析画面等）。
4. 本番 Supabase へマイグレーション適用。
5. アプリをリリース。旧バージョンが新フォーマットを扱えるか（表示のみなら OK）を確認。

## リスクと軽減策
| リスク | 説明 | 軽減策 |
| --- | --- | --- |
| タイムゾーン不一致 | 端末が JST 以外のタイムゾーンで実行されると `DateTime.now()` が現地時刻になる | `tz` パッケージ導入、または `DateTime.now().toUtc().add(const Duration(hours: 9))` で JST に正規化 |
| 乱数衝突 | Base62 11 文字でも理論上衝突はゼロではない | CSPRNG 利用 + Supabase UNIQUE 制約で検出。衝突時は再試行ロジックを実装 |
| 既存コードのフォーマット依存 | 連番部分を整数として扱う処理が残存 | 全コード検索とレビューを行い、必要なら `order_number` 形式非依存の実装へ置き換え |
| マイグレーションのダウンタイム | インデックス作成に時間がかかる可能性 | オンラインインデックス作成 (`CREATE INDEX CONCURRENTLY`) を検討し、事前にデータ件数を把握 |
| 旧データとの混在 | 新旧フォーマットが混在し、外部システムが解析できない | 旧フォーマットは互換表示とし、必要なら変換・マッピングテーブルを提供 |

## 検証・完了条件
- 新フォーマットの文字列が正規表現 `^[0-9]{8}T[0-9]{6}\+0900-[0-9A-Za-z]{11}$` を満たすこと。
- Supabase UNIQUE 制約が衝突を検知できること（ステージングで再現テスト）。
- チェックアウト後の注文番号表示、履歴検索、分析レポートが正しく動作する。
- ドキュメント（開発、運用、サポート向け）が更新され、ロールバック手順も定義済み。

## フォローアップ / 次のアクション
- 実装完了後に `docs/draft/order_number_generation.md` を更新し、新フォーマットと採番手順を反映。
- ベンチマーク結果や採番失敗ログをモニタリングし、必要なら採番 API のリトライ・リミット調整を行う。
- 外部連携（レシート印刷等）で新フォーマットを表示する場合は別途デザイン調整を検討。
